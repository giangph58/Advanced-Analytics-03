{"value":"{\"aid\": \"http://arxiv.org/abs/2503.24100v1\", \"title\": \"Fuzzing-based Mutation Testing of C/C++ CPS\", \"summary\": \"Mutation testing can help minimize the delivery of faulty software.\\nTherefore, it is a recommended practice for developing embedded software in\\nsafety-critical cyber-physical systems (CPS). However, state-of-the-art\\nmutation testing techniques for C and C++ software, which are common languages\\nfor CPS, depend on symbolic execution. Unfortunately, symbolic execution's\\nlimitations hinder its applicability (e.g., systems with black-box components).\\n  We propose relying on fuzz testing, which has demonstrated its effectiveness\\nfor C and C++ software. Fuzz testing tools automatically create test inputs\\nthat explore program branches in various ways, exercising statements in\\ndifferent program states, and thus enabling the detection of mutants, which is\\nour objective.\\n  We empirically evaluated our approach using software components from\\noperational satellite systems. Our assessment shows that our approach can\\ndetect between 40% and 90% of the mutants not detected by developers' test\\nsuites. Further, we empirically determined that the best results are obtained\\nby integrating the Clang compiler, a memory address sanitizer, and relying on\\nlaf-intel instrumentation to collect coverage and guide fuzzing. Our approach\\ndetects a significantly higher percentage of live mutants compared to symbolic\\nexecution, with an increase of up to 50 percentage points; further, we observed\\nthat although the combination of fuzzing and symbolic execution leads to\\nadditional mutants being killed, the benefits are minimal (a gain of less than\\none percentage point).\", \"main_category\": \"cs.SE\", \"categories\": \"cs.SE\", \"published\": \"2025-03-31T13:55:27Z\"}"}
