{"value":"{\"aid\": \"http://arxiv.org/abs/2505.05162v1\", \"title\": \"Testing Message-Passing Concurrency\", \"summary\": \"A key computational question underpinning the automated testing and\\nverification of concurrent programs is the \\\\emph{consistency question} --\\n\\\\emph{given a partial execution history, can it be completed in a consistent\\nmanner?} Due to its importance, consistency testing has been studied\\nextensively for memory models, as well as for database isolation levels. A\\ncommon theme in all these settings is the use of shared-memory as the primal\\nmode of interthread communication. On the other hand, modern programming\\nlanguages, such as Go, Rust and Kotlin, advocate a paradigm shift towards\\nchannel-based (i.e., message-passing) communication. However, the consistency\\nquestion for channel-based concurrency is currently poorly understood.\\n  In this paper we lift the study of fundamental consistency problems to\\nchannels, taking into account various input parameters, such as the number of\\nthreads executing, the number of channels, and the channel capacities. We draw\\na rich complexity landscape, including upper bounds that become polynomial when\\ncertain input parameters are fixed, as well as hardness lower bounds. Our upper\\nbounds are based on novel algorithms that can drive the verification of channel\\nconsistency in automated verification tools. Our lower bounds characterize\\nminimal input parameters that are sufficient for hardness to arise, and thus\\nshed light on the intricacies of testing channel-based concurrency. In\\ncombination, our upper and lower bounds characterize the boundary of\\n\\\\emph{tractability/intractability} of verifying channel consistency, and imply\\nthat our algorithms are often (nearly) optimal.\", \"main_category\": \"cs.PL\", \"categories\": \"cs.PL,cs.IT,math.IT\", \"published\": \"2025-05-08T11:57:28Z\"}"}
