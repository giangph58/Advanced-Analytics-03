{"value":"{\"aid\": \"http://arxiv.org/abs/2504.15550v1\", \"title\": \"Smooth, Integrated Proofs of Cryptographic Constant Time for\\n  Nondeterministic Programs and Compilers\", \"summary\": \"Formal verification of software and compilers has been used to rule out large\\nclasses of security-critical issues, but risk of unintentional information\\nleakage has received much less consideration. It is a key requirement for\\nformal specifications to leave some details of a system's behavior unspecified\\nso that future implementation changes can be accommodated, and yet it is\\nnonetheless expected that these choices would not be made based on confidential\\ninformation the system handles. This paper formalizes that notion using\\nomnisemantics and plain single-copy assertions, giving for the first time a\\nspecification of what it means for a nondeterministic program to be\\nconstant-time or more generally to avoid leaking (a part of) its inputs. We use\\nthis theory to prove data-leak-free execution of core cryptographic routines\\ncompiled from Bedrock2 C to RISC-V machine code, showing that the smooth\\nspecification and proof experience omnisemantics provides for nondeterminism\\nextends to constant-time properties in the same setting. We also study variants\\nof the key program-compiler contract, highlighting pitfalls of tempting\\nsimplifications and subtle consequences of how inputs to nondeterministic\\nchoices are constrained. Our results are backed by modular program-logic and\\ncompiler-correctness theorems, and they integrate into a neat end-to-end\\ntheorem in the Coq proof assistant.\", \"main_category\": \"cs.PL\", \"categories\": \"cs.PL\", \"published\": \"2025-04-22T03:12:31Z\"}"}
