{"value":"{\"aid\": \"http://arxiv.org/abs/2504.02443v1\", \"title\": \"Language-Integrated Recursive Queries\", \"summary\": \"Performance-critical industrial applications, including large-scale program,\\nnetwork, and distributed system analyses, rely on fixed-point computations. The\\nintroduction of recursive common table expressions (CTEs) using the WITH\\nRECURSIVE keyword in SQL:1999 extended the ability of relational database\\nsystems to handle fixed-point computations, unlocking significant performance\\nadvantages by allowing computation to move closer to the data. Yet with\\nrecursion, SQL becomes a Turing-complete programming language and, with that,\\nunrecoverable safety and correctness risks. SQL itself lacks a fixed semantics,\\nas the SQL specification is written in natural language, full of ambiguities\\nthat database vendors resolve in divergent ways. As a result, reasoning about\\nthe correctness of recursive SQL programs must rely on isolated mathematical\\nproperties of queries rather than wrestling a unified formal model out of a\\nlanguage with notoriously inconsistent semantics. To address these challenges,\\nwe propose a calculus that automatically derives mathematical properties from\\nembedded recursive queries and, depending on the database backend, rejects\\nqueries that may lead to the three classes of recursive query errors - database\\nerrors, incorrect results, and non-termination. We introduce TyQL, a practical\\nimplementation in Scala for safe, recursive language-integrated query. Using\\nNamed-Tuples and type-level pattern matching, TyQL ensures query portability\\nand safety, showing no performance penalty compared to raw SQL strings while\\nunlocking a three-orders-of-magnitude speedup over non-recursive SQL queries.\", \"main_category\": \"cs.PL\", \"categories\": \"cs.PL\", \"published\": \"2025-04-03T09:58:52Z\"}"}
