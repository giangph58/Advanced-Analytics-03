{"value":"{\"aid\": \"http://arxiv.org/abs/2504.21382v1\", \"title\": \"Robust and Scalable Renaming with Subquadratic Bits\", \"summary\": \"In the renaming problem, a set of $n$ nodes, each with a unique identity from\\na large namespace $[N]$, needs to obtain new unique identities in a smaller\\nnamespace $[M]$. A renaming algorithm is strong if $M=n$. Renaming is a\\nclassical problem in distributed computing with a range of applications, and\\nthere exist many time-efficient solutions for fault-tolerant renaming in\\nsynchronous message-passing systems. However, all previous algorithms send\\n$\\\\Omega(n^2)$ messages, and many of them also send large messages each\\ncontaining $\\\\Omega(n)$ bits. Moreover, most algorithms' performance do not\\nscale with the actual number of failures. These limitations restrict their\\npractical performance.\\n  We develop two new strong renaming algorithms, one tolerates up to $n-1$\\ncrash failures, and the other tolerates up to $(1/3-\\\\epsilon_0)n$ Byzantine\\nfailures for an arbitrarily small constant $\\\\epsilon_0>0$. The crash-resilient\\nalgorithm is always correct and always finishes within $O(\\\\log{n})$ rounds. It\\nsends $\\\\tilde{O}((f+1)\\\\cdot n)$ messages with high probability, where $f$ is\\nthe actual number of crashes. This implies that it sends subquadratic messages\\nas long as $f=o(n/\\\\log{n})$. The Byzantine-resilient algorithm trades time for\\ncommunication: it finishes within $\\\\tilde{O}(\\\\max\\\\{f,1\\\\})$ rounds and sends\\nonly $\\\\tilde{O}(f+n)$ messages, with high probability. Here, $f$ is the actual\\nnumber of Byzantine nodes. To obtain such strong guarantees, the\\nByzantine-resilient algorithm leverages shared randomness and message\\nauthentication. Both algorithms only send messages of size $O(\\\\log{N})$ bits.\\nTherefore, our crash-resilient algorithm incurs $o(n^2)$ communication cost as\\nlong as $f=o(n/(\\\\log{n}\\\\log{N}))$; and our Byzantine resilient algorithm incurs\\nalmost-linear communication cost. By deriving a lower bound, we conclude that\\nour algorithms achieve near-optimal communication cost in many cases.\", \"main_category\": \"cs.DC\", \"categories\": \"cs.DC\", \"published\": \"2025-04-30T07:31:35Z\"}"}
