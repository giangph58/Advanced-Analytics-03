{"value":"{\"aid\": \"http://arxiv.org/abs/2504.17327v1\", \"title\": \"Simple Universally Optimal Dijkstra\", \"summary\": \"Let G be a weighted (directed) graph with n vertices and m edges. Given a\\nsource vertex s, Dijkstra's algorithm computes the shortest path lengths from s\\nto all other vertices in O(m + n log n) time. This bound is known to be\\nworst-case optimal via a reduction to sorting. Theoretical computer science has\\ndeveloped numerous fine-grained frameworks for analyzing algorithmic\\nperformance beyond standard worst-case analysis, such as instance optimality\\nand output sensitivity. Haeupler et al. [FOCS '24] consider the notion of\\nuniversal optimality, a refined complexity measure that accounts for both the\\ngraph topology and the edge weights. For a fixed graph topology, the universal\\nrunning time of a weighted graph algorithm is defined as its worst-case running\\ntime over all possible edge weightings of G. An algorithm is universally\\noptimal if no other algorithm achieves a better asymptotic universal running\\ntime on any particular graph topology. They show that Dijkstra's algorithm can\\nbe made universally optimal by replacing the heap with a custom data structure.\\n  We revisit their result. We introduce a simple heap property called timestamp\\noptimality, where the cost of popping an element x is logarithmic in the number\\nof elements inserted between pushing and popping x. We show that timestamp\\noptimal heaps are not only easier to define but also easier to implement. Using\\nthese timestamps, we provide a significantly simpler proof that Dijkstra's\\nalgorithm, with the right kind of heap, is universally optimal.\", \"main_category\": \"cs.DS\", \"categories\": \"cs.DS\", \"published\": \"2025-04-24T07:40:44Z\"}"}
