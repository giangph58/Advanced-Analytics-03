{"value":"{\"aid\": \"http://arxiv.org/abs/2504.16777v1\", \"title\": \"Systemic Flakiness: An Empirical Analysis of Co-Occurring Flaky Test\\n  Failures\", \"summary\": \"Flaky tests produce inconsistent outcomes without code changes, creating\\nmajor challenges for software developers. An industrial case study reported\\nthat developers spend 1.28% of their time repairing flaky tests at a monthly\\ncost of $2,250. We discovered that flaky tests often exist in clusters, with\\nco-occurring failures that share the same root causes, which we call systemic\\nflakiness. This suggests that developers can reduce repair costs by addressing\\nshared root causes, enabling them to fix multiple flaky tests at once rather\\nthan tackling them individually. This study represents an inflection point by\\nchallenging the deep-seated assumption that flaky test failures are isolated\\noccurrences. We used an established dataset of 10,000 test suite runs from 24\\nJava projects on GitHub, spanning domains from data orchestration to job\\nscheduling. It contains 810 flaky tests, which we levered to perform a\\nmixed-method empirical analysis of co-occurring flaky test failures. Systemic\\nflakiness is significant and widespread. We performed agglomerative clustering\\nof flaky tests based on their failure co-occurrence, finding that 75% of flaky\\ntests across all projects belong to a cluster, with a mean cluster size of 13.5\\nflaky tests. Instead of requiring 10,000 test suite runs to identify systemic\\nflakiness, we demonstrated a lightweight alternative by training machine\\nlearning models based on static test case distance measures. Through manual\\ninspection of stack traces, conducted independently by four authors and\\nresolved through negotiated agreement, we identified intermittent networking\\nissues and instabilities in external dependencies as the predominant causes of\\nsystemic flakiness.\", \"main_category\": \"cs.SE\", \"categories\": \"cs.SE\", \"published\": \"2025-04-23T14:51:23Z\"}"}
