{"value":"{\"aid\": \"http://arxiv.org/abs/2504.01582v1\", \"title\": \"MERE: Hardware-Software Co-Design for Masking Cache Miss Latency in\\n  Embedded Processors\", \"summary\": \"Runahead execution is a technique to mask memory latency caused by irregular\\nmemory accesses. By pre-executing the application code during occurrences of\\nlong-latency operations and prefetching anticipated cache-missed data into the\\ncache hierarchy, runahead effectively masks memory latency for subsequent cache\\nmisses and achieves high prefetching accuracy; however, this technique has been\\nlimited to superscalar out-of-order and superscalar in-order cores. For\\nimplementation in scalar in-order cores, the challenges of\\narea-/energy-constraint and severe cache contention remain.\\n  Here, we build the first full-stack system featuring runahead, MERE, from SoC\\nand a dedicated ISA to the OS and programming model. Through this deployment,\\nwe show that enabling runahead in scalar in-order cores is possible, with\\nminimal area and power overheads, while still achieving high performance. By\\nre-constructing the sequential runahead employing a hardware/software co-design\\napproach, the system can be implemented on a mature processor and SoC. Building\\non this, an adaptive runahead mechanism is proposed to mitigate the severe\\ncache contention in scalar in-order cores. Combining this, we provide a\\ncomprehensive solution for embedded processors managing irregular workloads.\\nOur evaluation demonstrates that the proposed MERE attains 93.5% of a 2-wide\\nout-of-order core's performance while constraining area and power overheads\\nbelow 5%, with the adaptive runahead mechanism delivering an additional 20.1%\\nperformance gain through mitigating the severe cache contention issues.\", \"main_category\": \"cs.AR\", \"categories\": \"cs.AR\", \"published\": \"2025-04-02T10:38:25Z\"}"}
