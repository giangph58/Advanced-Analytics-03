{"value":"{\"aid\": \"http://arxiv.org/abs/2504.02246v1\", \"title\": \"C*: Unifying Programming and Verification in C\", \"summary\": \"Ensuring the correct functionality of systems software, given its\\nsafety-critical and low-level nature, is a primary focus in formal verification\\nresearch and applications. Despite advances in verification tooling,\\nconventional programmers are rarely involved in the verification of their own\\ncode, resulting in higher development and maintenance costs for verified\\nsoftware. A key barrier to programmer participation in verification practices\\nis the disconnect of environments and paradigms between programming and\\nverification practices, which limits accessibility and real-time verification.\\n  We introduce C*, a proof-integrated language design for C programming. C*\\nextends C with verification capabilities, powered by a symbolic execution\\nengine and an LCF-style proof kernel. It enables real-time verification by\\nallowing programmers to embed proof-code blocks alongside implementation code,\\nfacilitating interactive updates to the current proof state. Its expressive and\\nextensible proof support allows users to build reusable libraries of logical\\ndefinitions, theorems, and programmable proof automation. Crucially, C* unifies\\nimplementation and proof code development by using C as the common language.\\n  We implemented a prototype of C* and evaluated it on a representative\\nbenchmark of small C programs and a challenging real-world case study: the\\nattach function of pKVM's buddy allocator. Our results demonstrate that C*\\nsupports the verification of a broad subset of C programming idioms and\\neffectively handles complex reasoning tasks in real-world scenarios.\", \"main_category\": \"cs.PL\", \"categories\": \"cs.PL,cs.SE\", \"published\": \"2025-04-03T03:22:22Z\"}"}
